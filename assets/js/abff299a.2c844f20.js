"use strict";(self.webpackChunksurge_docs=self.webpackChunksurge_docs||[]).push([[99],{2400:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>n,metadata:()=>d,toc:()=>a});var o=s(4848),i=s(8453);const n={sidebar_position:2},r="Common Issues",d={id:"Troubleshooting/common-issues",title:"Common Issues",description:"This page contains common issues and their solutions.",source:"@site/docs/Troubleshooting/common-issues.mdx",sourceDirName:"Troubleshooting",slug:"/Troubleshooting/common-issues",permalink:"/docs/Troubleshooting/common-issues",draft:!1,unlisted:!1,editUrl:"https://github.com/NethermindEth/surge/tree/main/docs/docs/Troubleshooting/common-issues.mdx",tags:[],version:"current",lastUpdatedAt:1737546122e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Error Codes",permalink:"/docs/Troubleshooting/error-codes"}},l={},a=[{value:"After each L1 - L2 bridged tx, why isn&#39;t it processed until a new L2 block is produced?",id:"after-each-l1---l2-bridged-tx-why-isnt-it-processed-until-a-new-l2-block-is-produced",level:4},{value:"For L2 - L1 bridged tx to be processed, there should be L1 - L2 bridged txs. Why is this?",id:"for-l2---l1-bridged-tx-to-be-processed-there-should-be-l1---l2-bridged-txs-why-is-this",level:4},{value:"I have bridged 3 times from L2 to L1, but bridged txs are not being processed.",id:"i-have-bridged-3-times-from-l2-to-l1-but-bridged-txs-are-not-being-processed",level:4}];function c(e){const t={h1:"h1",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"common-issues",children:"Common Issues"})}),"\n",(0,o.jsx)(t.p,{children:"This page contains common issues and their solutions."}),"\n",(0,o.jsx)(t.h4,{id:"after-each-l1---l2-bridged-tx-why-isnt-it-processed-until-a-new-l2-block-is-produced",children:"After each L1 - L2 bridged tx, why isn't it processed until a new L2 block is produced?"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"L2 receives L1's state via an anchor transaction. The anchor transaction sends the state root at the last L1 block. So, to get the state root of the bridging txn block, we need another block on top of it. If we are not proposing empty blocks, then at least one L2 tx needs to be sent to force a new block to be generated."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Another thing to remember: This extra L2 block must be a part of the L1 block that follows the L1 block containing the bridging txn. This kind of happens implicitly at the moment since kurtosis blocks are fast."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h4,{id:"for-l2---l1-bridged-tx-to-be-processed-there-should-be-l1---l2-bridged-txs-why-is-this",children:"For L2 - L1 bridged tx to be processed, there should be L1 - L2 bridged txs. Why is this?"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"The main requirement is that if 1 ETH is bridged from L1 to L2, and in return when we bridge back same 1 ETH from L2 -> L1, we also end up paying a small fee to the relayer. That fee is added on top of 1 ETH."}),"\n",(0,o.jsx)(t.li,{children:"Now, unless a lot of people have bridged in and the pool is larger than 1 eth. This won\u2019t work, since the fee can never be paid as the total amount in the bridge is 1 ETH itself."}),"\n"]}),"\n",(0,o.jsx)(t.h4,{id:"i-have-bridged-3-times-from-l2-to-l1-but-bridged-txs-are-not-being-processed",children:"I have bridged 3 times from L2 to L1, but bridged txs are not being processed."}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Verification attempt every 4 blocks, your txn might not be verified yet."}),"\n",(0,o.jsx)(t.li,{children:"Try bridging again."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>d});var o=s(6540);const i={},n=o.createContext(i);function r(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);