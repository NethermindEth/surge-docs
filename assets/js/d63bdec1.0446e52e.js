"use strict";(self.webpackChunksurge_docs=self.webpackChunksurge_docs||[]).push([[475],{1297:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>d,toc:()=>h});var s=t(4848),n=t(8453);const r={sidebar_position:2},i="Common Devnet Issues",d={id:"Troubleshooting/common-devnet-issues",title:"Common Devnet Issues",description:"This page contains common issues while setting up the devnet and their solutions.",source:"@site/docs/Troubleshooting/common-devnet-issues.mdx",sourceDirName:"Troubleshooting",slug:"/Troubleshooting/common-devnet-issues",permalink:"/docs/Troubleshooting/common-devnet-issues",draft:!1,unlisted:!1,editUrl:"https://github.com/NethermindEth/surge/tree/main/docs/docs/Troubleshooting/common-devnet-issues.mdx",tags:[],version:"current",lastUpdatedAt:174222577e4,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Error Codes",permalink:"/docs/Troubleshooting/error-codes"}},l={},h=[{value:"After each L1 - L2 bridged tx, why isn&#39;t it processed until a new L2 block is produced?",id:"after-each-l1---l2-bridged-tx-why-isnt-it-processed-until-a-new-l2-block-is-produced",level:4},{value:"For L2 - L1 bridged tx to be processed, there should be L1 - L2 bridged txs. Why is this?",id:"for-l2---l1-bridged-tx-to-be-processed-there-should-be-l1---l2-bridged-txs-why-is-this",level:4},{value:"I have bridged 3 times from L2 to L1, but bridged txs are not being processed.",id:"i-have-bridged-3-times-from-l2-to-l1-but-bridged-txs-are-not-being-processed",level:4},{value:"Why do I need to use the same key for prover and proposer?",id:"why-do-i-need-to-use-the-same-key-for-prover-and-proposer",level:4}];function a(e){const o={h1:"h1",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.header,{children:(0,s.jsx)(o.h1,{id:"common-devnet-issues",children:"Common Devnet Issues"})}),"\n",(0,s.jsx)(o.p,{children:"This page contains common issues while setting up the devnet and their solutions."}),"\n",(0,s.jsx)(o.h4,{id:"after-each-l1---l2-bridged-tx-why-isnt-it-processed-until-a-new-l2-block-is-produced",children:"After each L1 - L2 bridged tx, why isn't it processed until a new L2 block is produced?"}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsx)(o.p,{children:"L2 receives L1's state via an anchor transaction. The anchor transaction sends the state root at the last L1 block. So, to get the state root of the bridging txn block, we need another block on top of it. If we are not proposing empty blocks, then at least one L2 tx needs to be sent to force a new block to be generated."}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsx)(o.p,{children:"Another thing to remember: This extra L2 block must be a part of the L1 block that follows the L1 block containing the bridging txn. This kind of happens implicitly at the moment since kurtosis blocks are fast."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(o.h4,{id:"for-l2---l1-bridged-tx-to-be-processed-there-should-be-l1---l2-bridged-txs-why-is-this",children:"For L2 - L1 bridged tx to be processed, there should be L1 - L2 bridged txs. Why is this?"}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsx)(o.li,{children:"The main requirement is that if 1 ETH is bridged from L1 to L2, and in return when we bridge back same 1 ETH from L2 -> L1, we also end up paying a small fee to the relayer. That fee is added on top of 1 ETH."}),"\n",(0,s.jsx)(o.li,{children:"Now, unless a lot of people have bridged in and the pool is larger than 1 eth. This won\u2019t work, since the fee can never be paid as the total amount in the bridge is 1 ETH itself."}),"\n"]}),"\n",(0,s.jsx)(o.h4,{id:"i-have-bridged-3-times-from-l2-to-l1-but-bridged-txs-are-not-being-processed",children:"I have bridged 3 times from L2 to L1, but bridged txs are not being processed."}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsx)(o.li,{children:"Verification attempt every 4 blocks, your txn might not be verified yet."}),"\n",(0,s.jsx)(o.li,{children:"Try bridging again."}),"\n"]}),"\n",(0,s.jsx)(o.h4,{id:"why-do-i-need-to-use-the-same-key-for-prover-and-proposer",children:"Why do I need to use the same key for prover and proposer?"}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsx)(o.li,{children:"The contract is designed to only accept proofs from the proposer's address during the proving window."}),"\n",(0,s.jsx)(o.li,{children:"Non-proposer addresses can only submit proofs outside of the proving window."}),"\n",(0,s.jsx)(o.li,{children:"Therefore, to ensure your proofs can be submitted during the proving window, the same key must be used for both proposing and proving."}),"\n"]})]})}function c(e={}){const{wrapper:o}={...(0,n.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>i,x:()=>d});var s=t(6540);const n={},r=s.createContext(n);function i(e){const o=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function d(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(r.Provider,{value:o},e.children)}}}]);