"use strict";(self.webpackChunksurge_docs=self.webpackChunksurge_docs||[]).push([[192],{4174:(e,n,i)=>{i.d(n,{Ay:()=>c,RM:()=>o});var r=i(4848),s=i(8453);const o=[];function t(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.code,{children:"chain_spec_list.json"})," and ",(0,r.jsx)(n.code,{children:"config.json"})," files are placed in ",(0,r.jsx)(n.code,{children:"raiko/host/config/devnet"})," for devnet and ",(0,r.jsx)(n.code,{children:"raiko/host/config/testnet"})," for testnet.\nYou can edit existing configs or create new ones based on your chain configuration."]}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.a,{href:"https://github.com/NethermindEth/simple-surge-node",children:"Simple Surge Node"}),", the ",(0,r.jsx)(n.code,{children:"surge-protocol-deployer.sh"})," deployment script\nwill generate ",(0,r.jsx)(n.code,{children:"chain_spec_list.json"})," for you after the ",(0,r.jsx)(n.code,{children:"Running provers? (true/false) [default: false]"})," prompt."]}),(0,r.jsxs)(n.p,{children:["You just need to copy it from ",(0,r.jsx)(n.code,{children:"simple-surge-node/configs/chain_spec_list_default.json"})," into your prover config folder\n(e.g., ",(0,r.jsx)(n.code,{children:"raiko/host/config/devnet/chain_spec_list.json"}),")."]})]}),"\n",(0,r.jsxs)(n.p,{children:["Here are the most important parameters to check in ",(0,r.jsx)(n.code,{children:"config.json"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"address"}),": The address of the prover server"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"network"}),": The network name of the L2"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"concurrency_limit"}),": The number of concurrent proving tasks the prover can handle. Note that this\nvalue should be set to the number of GPUs available on the prover machine."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"l1_network"}),": The network name of the L1"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ballot_zk"}),": Configuration for ",(0,r.jsx)(n.code,{children:"zk_any"})," request"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ballot_sgx"}),": Configuration for ",(0,r.jsx)(n.code,{children:"sgx_any"})," request"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This ",(0,r.jsx)(n.code,{children:"config.json"})," file is used as the default proof request config, but clients can override it with specific values."]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"chain_spec_list.json"})," file is generated when deploying the protocol. You should copy it as-is. Don't change anything in this file unless you know what you're doing."]})]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}},8366:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"guides/running-surge/provers/sgx-prover","title":"SGX Prover","description":"This guide provides step-by-step instructions to set up the SGX prover for Surge using Docker.","source":"@site/docs/guides/running-surge/provers/sgx-prover.mdx","sourceDirName":"guides/running-surge/provers","slug":"/guides/running-surge/provers/sgx-prover","permalink":"/docs/guides/running-surge/provers/sgx-prover","draft":false,"unlisted":false,"editUrl":"https://github.com/NethermindEth/surge-docs/tree/main/docs/guides/running-surge/provers/sgx-prover.mdx","tags":[],"version":"current","lastUpdatedAt":1761835737000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Set up Provers","permalink":"/docs/guides/running-surge/provers/"},"next":{"title":"SP1 & RISC Zero Provers","permalink":"/docs/guides/running-surge/provers/sp1-and-risc0-provers"}}');var s=i(4848),o=i(8453),t=i(4174);const c={sidebar_position:1},d="SGX Prover",l={},a=[{value:"Prerequisites",id:"prerequisites",level:3},{value:"1. Fetch Collateral Information",id:"1-fetch-collateral-information",level:3},{value:"2. Generating PCCS Certificates",id:"2-generating-pccs-certificates",level:3},{value:"3. Setup Chain Spec and Config",id:"3-setup-chain-spec-and-config",level:3},...t.RM,{value:"4. Configure Environment Variables",id:"4-configure-environment-variables",level:3},{value:"5. Build and Run the Prover",id:"5-build-and-run-the-prover",level:3},{value:"Using Pre-built Image from Docker Hub",id:"using-pre-built-image-from-docker-hub",level:4},{value:"Build the Image Yourself",id:"build-the-image-yourself",level:4},{value:"6. Verify the Prover is Running",id:"6-verify-the-prover-is-running",level:3},{value:"7. Next Steps",id:"7-next-steps",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sgx-prover",children:"SGX Prover"})}),"\n",(0,s.jsx)(n.p,{children:"This guide provides step-by-step instructions to set up the SGX prover for Surge using Docker.\nThe SGX prover utilizes Intel's Software Guard Extensions (SGX) to create a secure environment for generating\ncryptographic proofs that validate Layer 2 blocks."}),"\n",(0,s.jsx)(n.p,{children:"The SGX prover contains two components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sgx-reth"})," prover - Rust SGX prover that generates proofs for the rollup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sgx-geth"})," (Gaiko) prover - Golang SGX prover that generates proofs for the rollup"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Machine with SGX support"}),"\n",(0,s.jsx)(n.li,{children:"Docker"}),"\n",(0,s.jsx)(n.li,{children:"L1 Accounts with funds (one for the prover, one for prover registry)"}),"\n",(0,s.jsx)(n.li,{children:"L1 RPC URL"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"1-fetch-collateral-information",children:"1. Fetch Collateral Information"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"You can skip this section if you have already set up the PCCS configuration before."})}),"\n",(0,s.jsx)(n.p,{children:"First, fetch the collateral information from Intel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'FMSPC="00906ED50000"\n\nTCB_FILE="tcb.json"\nQE_IDENTITY_FILE="qe_identity.json"\n\ncurl -X GET "https://api.trustedservices.intel.com/sgx/certification/v3/tcb?fmspc=${FMSPC}" > ${TCB_FILE}\ncurl -X GET "https://api.trustedservices.intel.com/sgx/certification/v3/qe/identity" > ${QE_IDENTITY_FILE}\n\njq \'.tcbInfo.fmspc |= ascii_downcase\' ${TCB_FILE} > temp.json && mv temp.json ${TCB_FILE}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-generating-pccs-certificates",children:"2. Generating PCCS Certificates"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"You can skip this section if you have already generated the PCCS configuration before."})}),"\n",(0,s.jsx)(n.p,{children:"Before running the Raiko Docker container, you need to fulfill some SGX-specific prerequisites,\nwhich include setting up the PCCS (Provisioning Certificate Caching Service) configuration.\nThe PCCS service is responsible for retrieving PCK Certificates and other collaterals on-demand\nfrom the internet at runtime, and then caching them in a local database.\nThe PCCS exposes similar HTTPS interfaces as Intel's Provisioning Certificate Service."}),"\n",(0,s.jsx)(n.p,{children:"Begin the configuration process by generating an SSL certificate:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"mkdir ~/.config\nmkdir ~/.config/sgx-pccs\ncd ~/.config/sgx-pccs\nopenssl genrsa -out private.pem 2048\nchmod 644 private.pem  # Docker container needs access\nopenssl req -new -key private.pem -out csr.pem\nopenssl x509 -req -days 365 -in csr.pem -signkey private.pem -out file.crt\nrm csr.pem\n"})}),"\n",(0,s.jsx)(n.p,{children:"Download the configuration file:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"curl -s https://raw.githubusercontent.com/taikoxyz/raiko/refs/heads/main/docs/default.json > ~/.config/sgx-pccs/default.json\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Copy the ",(0,s.jsx)(n.code,{children:"default.json"})," file to the ",(0,s.jsx)(n.code,{children:".config/sgx-pccs"})," directory you created earlier. The Raiko container will mount this as a volume. Open the file for editing and configure the following parameters as recommended by Intel's manual:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ApiKey"}),": The PCCS uses this API key to request collaterals from Intel's Provisioning Certificate Service. You need to subscribe first to obtain an API key. Use either the primary or secondary key obtained from subscribing to Intel PCS Service."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"UserTokenHash"}),": SHA512 hash of the user token for the PCCS client to register a platform. The PCK Cert ID retrieval tool uses this token to send platform information to PCCS. Generate using: ",(0,s.jsx)(n.code,{children:"echo -n \"user_password\" | sha512sum | tr -d '[:space:]-'"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AdminTokenHash"}),": SHA512 hash of the administrator token for manual refresh of cached artifacts. Generate using: ",(0,s.jsx)(n.code,{children:"echo -n \"admin_password\" | sha512sum | tr -d '[:space:]-'"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hosts"}),": Replace with ",(0,s.jsx)(n.code,{children:'"0.0.0.0"'})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Ensure Docker can access the file by modifying its permissions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"chmod 644 default.json\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-setup-chain-spec-and-config",children:"3. Setup Chain Spec and Config"}),"\n",(0,s.jsx)(t.Ay,{}),"\n",(0,s.jsx)(n.h3,{id:"4-configure-environment-variables",children:"4. Configure Environment Variables"}),"\n",(0,s.jsxs)(n.p,{children:["Copy the sample ",(0,s.jsx)(n.code,{children:".env"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd raiko/docker\ncp .env.sample .env\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Edit the ",(0,s.jsx)(n.code,{children:".env"})," file and configure the following important variables:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RAIKO_CONF_DIR"})," - Directory where your Raiko configuration files are stored"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BASE_CONFIG_FILE"})," - Base configuration file for Raiko inside ",(0,s.jsx)(n.code,{children:"$RAIKO_CONF_DIR"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BASE_CHAINSPEC_FILE"})," - Base chainspec file for Raiko inside ",(0,s.jsx)(n.code,{children:"$RAIKO_CONF_DIR"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SGX_*_INSTANCE_ID"})," - SGX Instance ID for specific hardfork"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SGXGETH_*_INSTANCE_ID"})," - SGXGeth (Gaiko) Instance ID for specific hardfork"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RUST_LOG"})," - Log level for Rust (",(0,s.jsx)(n.code,{children:"info"}),", ",(0,s.jsx)(n.code,{children:"debug"}),", ",(0,s.jsx)(n.code,{children:"warn"}),", ",(0,s.jsx)(n.code,{children:"error"}),", or ",(0,s.jsx)(n.code,{children:"trace"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["You can leave ",(0,s.jsx)(n.code,{children:"RAIKO_CONF_DIR"}),", ",(0,s.jsx)(n.code,{children:"BASE_CONFIG_FILE"}),", and ",(0,s.jsx)(n.code,{children:"BASE_CHAINSPEC_FILE"})," as default if you have placed your config files in ",(0,s.jsx)(n.code,{children:"raiko/host/config/devnet"}),"."]}),(0,s.jsxs)(n.p,{children:["Environment variables ",(0,s.jsx)(n.code,{children:"SGX_*_INSTANCE_ID"})," and ",(0,s.jsx)(n.code,{children:"SGXGETH_*_INSTANCE_ID"})," will be generated for you\nin ",(0,s.jsx)(n.a,{href:"https://github.com/NethermindEth/simple-surge-node",children:"Simple Surge Node"})," ",(0,s.jsx)(n.code,{children:"surge-protocol-deployer.sh"})," deployment script\nafter ",(0,s.jsx)(n.code,{children:"Running provers? (true/false) [default: false]"})," prompt."]})]}),"\n",(0,s.jsx)(n.h3,{id:"5-build-and-run-the-prover",children:"5. Build and Run the Prover"}),"\n",(0,s.jsx)(n.p,{children:"You have two options to run the prover:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use a pre-built image from Docker Hub"}),"\n",(0,s.jsx)(n.li,{children:"Build the image yourself"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"using-pre-built-image-from-docker-hub",children:"Using Pre-built Image from Docker Hub"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"docker-compose.yml"})," file uses the latest Raiko SGX image from Docker Hub by default.\nRun the following commands:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd docker # Navigate to the docker directory inside raiko\ndocker compose up init # Initialize the prover\ndocker compose up raiko -d --force-recreate # Run the prover in detached mode\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.p,{children:"If you want to re-initialize the prover, keep in mind that you need to delete existing keys:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"rm -r ~/.config/raiko/secrets\n"})})]}),"\n",(0,s.jsxs)(n.p,{children:["To use a specific version, update the image tag in the ",(0,s.jsx)(n.code,{children:"docker-compose.yml"})," file.\nCheck the ",(0,s.jsx)(n.a,{href:"https://github.com/NethermindEth/raiko",children:"Raiko repository"})," for available releases.\nUpdate the ",(0,s.jsx)(n.code,{children:"image"})," field in ",(0,s.jsx)(n.code,{children:"docker/docker-compose.yml"})," for both ",(0,s.jsx)(n.code,{children:"raiko"})," and ",(0,s.jsx)(n.code,{children:"init"})," services."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if the latest release is ",(0,s.jsx)(n.code,{children:"v1.8.5-surge"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"services:\n  init:\n    image: nethermind.jfrog.io/core-oci-local-prod/raiko-sgx:v1.8.5-surge\n    ...\n  raiko:\n    image: nethermind.jfrog.io/core-oci-local-prod/raiko-sgx:v1.8.5-surge\n    ...\n"})}),"\n",(0,s.jsx)(n.h4,{id:"build-the-image-yourself",children:"Build the Image Yourself"}),"\n",(0,s.jsx)(n.p,{children:"You may want to build the image yourself if you have made local changes to the Raiko codebase or want to use a specific commit."}),"\n",(0,s.jsxs)(n.p,{children:["To build the image from the ",(0,s.jsx)(n.code,{children:"raiko"})," directory:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd docker # Navigate to the docker directory inside raiko\ndocker compose up init --build # Build and Init the prover\ndocker compose up raiko -d --force-recreate --build # Build and Run the prover\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.p,{children:"If you want to re-initialize the prover, keep in mind that you need to delete existing keys:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"rm -r ~/.config/raiko/secrets\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"6-verify-the-prover-is-running",children:"6. Verify the Prover is Running"}),"\n",(0,s.jsx)(n.p,{children:"Your SGX prover should now be operational. To verify it's running correctly, check the container logs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker logs -f raiko\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["If you encounter any issues while following these instructions, refer to the ",(0,s.jsx)(n.a,{href:"https://github.com/NethermindEth/raiko/blob/main/docs/README_Docker_and_RA.md",children:"Raiko Docker and RA Documentation"})," for additional guidance."]})}),"\n",(0,s.jsx)(n.h3,{id:"7-next-steps",children:"7. Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["Next you can set up an SP1 & RISC Zero prover by following the instructions in the ",(0,s.jsx)(n.a,{href:"/docs/guides/running-surge/provers/sp1-and-risc0-provers",children:"SP1 & RISC Zero Prover"})," guide."]}),"\n",(0,s.jsxs)(n.p,{children:["If you have already done it, the next step is to register your provers in the protocol. Follow the instructions in the ",(0,s.jsx)(n.a,{href:"/docs/guides/running-surge/provers/register-provers",children:"Register Provers"})," guide."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var r=i(6540);const s={},o=r.createContext(s);function t(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);