"use strict";(self.webpackChunksurge_docs=self.webpackChunksurge_docs||[]).push([[508],{8390:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"guides/running-surge/provers/index","title":"Set up Provers","description":"You can skip deploying provers in a local devnet if you only want to test basic transaction flow and block proposals. However, because Surge uses a 2-of-4 multi-prover security model, without at least two provers running:","source":"@site/docs/guides/running-surge/provers/index.mdx","sourceDirName":"guides/running-surge/provers","slug":"/guides/running-surge/provers/","permalink":"/docs/guides/running-surge/provers/","draft":false,"unlisted":false,"editUrl":"https://github.com/NethermindEth/surge-docs/tree/main/docs/guides/running-surge/provers/index.mdx","tags":[],"version":"current","lastUpdatedAt":1761209560000,"sidebarPosition":3,"frontMatter":{"title":"Set up Provers","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Deploy L2 and Surge Protocols","permalink":"/docs/guides/running-surge/deploy-l2"},"next":{"title":"SGX Prover","permalink":"/docs/guides/running-surge/provers/sgx-prover"}}');var s=r(4848),i=r(8453);const t={title:"Set up Provers",sidebar_position:3},a="Set up a Prover",l={},c=[{value:"Understanding Provers in Surge",id:"understanding-provers-in-surge",level:2},{value:"What is a Prover?",id:"what-is-a-prover",level:3},{value:"Why Do You Need Provers?",id:"why-do-you-need-provers",level:3},{value:"How Do Provers Work?",id:"how-do-provers-work",level:3},{value:"Prover Requirements for Surge",id:"prover-requirements-for-surge",level:2},{value:"Surge Proof Systems",id:"surge-proof-systems",level:3},{value:"Prover Collateral Requirements",id:"prover-collateral-requirements",level:3},{value:"Proving Liveness Bond on Testnet",id:"proving-liveness-bond-on-testnet",level:3}];function d(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"set-up-a-prover",children:"Set up a Prover"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["You ",(0,s.jsx)(n.strong,{children:"can"})," skip deploying provers in a local devnet if you only want to test basic transaction flow and block proposals. However, because Surge uses a ",(0,s.jsx)(n.strong,{children:"2-of-4 multi-prover security model"}),", without ",(0,s.jsx)(n.strong,{children:"at least two"})," provers running:"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No L2 blocks will ever be proven or finalized on-chain."}),"\n",(0,s.jsx)(n.li,{children:"Any actions requiring finalized state (e.g., bridging back to L1, claiming certain rewards) will remain pending or unavailable."}),"\n"]}),(0,s.jsx)(n.p,{children:"Deploying a prover can be challenging due to:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware Requirements"}),": Certain provers (e.g., SGX) require specialized hardware or secure enclaves."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Setup"}),": Installing and configuring toolchains, drivers, or required libraries can be time-consuming."]}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"In a based rollup like Surge, provers generate cryptographic proofs verifying L2 blocks proposed by proposers. These proofs are then submitted on-chain through a prover-relayer, marking blocks as verified (finalized)."}),"\n",(0,s.jsx)(n.p,{children:"Without provers submitting proofs, blocks remain unverified, limiting critical functionalities such as cross-chain finalizations."}),"\n",(0,s.jsxs)(n.p,{children:["To see how provers fit into the overall system, refer to the ",(0,s.jsx)(n.a,{href:"/docs/about/architecture",children:"Surge Architecture documentation"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"understanding-provers-in-surge",children:"Understanding Provers in Surge"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-a-prover",children:"What is a Prover?"}),"\n",(0,s.jsx)(n.p,{children:"A prover is a component responsible for generating cryptographic proofs that validate the correctness and integrity of Layer 2 transactions and blocks. Surge leverages multiple provers \u2014 four independent ones in total \u2014 to ensure the security and reliability of rollup chains."}),"\n",(0,s.jsx)(n.h3,{id:"why-do-you-need-provers",children:"Why Do You Need Provers?"}),"\n",(0,s.jsx)(n.p,{children:"Provers are essential because:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"They guarantee that only valid transactions and blocks are finalized on-chain."}),"\n",(0,s.jsx)(n.li,{children:"They enable trustless, secure interactions between Layer 2 and Layer 1, facilitating safe bridging and asset transfers."}),"\n",(0,s.jsx)(n.li,{children:"They maintain the integrity and finality of the blockchain, preventing invalid or fraudulent state transitions."}),"\n",(0,s.jsxs)(n.li,{children:["Surge's ",(0,s.jsx)(n.strong,{children:"2-of-4 model"})," means that having two of these provers independently confirm a block is sufficient to finalize it on-chain."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"how-do-provers-work",children:"How Do Provers Work?"}),"\n",(0,s.jsx)(n.p,{children:"Provers execute computationally intensive algorithms to create succinct proofs that validate batches of L2 transactions. Once generated, these proofs are submitted on-chain via a prover-relayer, which then finalizes and confirms the validity of these transactions on the blockchain\u2014provided at least two of the four available provers agree on the block."}),"\n",(0,s.jsx)(n.h2,{id:"prover-requirements-for-surge",children:"Prover Requirements for Surge"}),"\n",(0,s.jsx)(n.h3,{id:"surge-proof-systems",children:"Surge Proof Systems"}),"\n",(0,s.jsx)(n.p,{children:"Surge supports four provers in production scenarios:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guides/running-surge/provers/sgx-prover",children:"SGX"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guides/running-surge/provers/sgx-prover",children:"SGXGETH"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guides/running-surge/provers/sp1-and-risc0-provers",children:"RISC0"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guides/running-surge/provers/sp1-and-risc0-provers",children:"SP1"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Although you only need ",(0,s.jsx)(n.strong,{children:"two"})," of these provers to finalize blocks under Surge\u2019s 2-of-4 security model, you may choose to run all four for maximum redundancy and security. Each prover has distinct setup and operational requirements. Follow the respective guides carefully to properly configure, deploy, and maintain each."]}),"\n",(0,s.jsx)(n.h3,{id:"prover-collateral-requirements",children:"Prover Collateral Requirements"}),"\n",(0,s.jsx)(n.p,{children:"In Surge, every proposed block needs to be proven. To ensure a 1-to-1 mapping from proposals to proofs, Surge requires proposers to provide collateral; the proving liveness bond, committing to submitting the proof within the proving liveness window (currently set to 24 hours), or forfeitting the the proving liveness bond. In the event that the original proposer does not submit the proof in time, anyone can instead submit a proof for the block, and collect the proving liveness bond. As such, the proving liveness bond acts as both an incentive for the original prover to submit the proof, and as an incentive for someone else to provide the proof in case of original proposer failure."}),"\n",(0,s.jsx)(n.p,{children:"With this in mind, the proving liveness bond needs to be large enough to ensure both of these incentives are achieved.\nThis worst-case cost for providing a Surge proof involves:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"an upperbound cost to submit and verify the proof on-chain."}),"\n",(0,s.jsx)(n.li,{children:"the cost to run all 4 provers, in the worst case scenario where there is a bug in 1 of the 4 provers."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["On mainnet, we can use mainnet ETH as the collateral, creating a clear financial incentive for ensuring proving tasks are completed.\nOn testnet however, ",(0,s.jsx)(n.strong,{children:"no financial incentive for proving exists"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"proving-liveness-bond-on-testnet",children:"Proving Liveness Bond on Testnet"}),"\n",(0,s.jsx)(n.p,{children:"To handle this lack of financial incentive on testnet, we have chosen the proving liveness bond to be 10,000 testnet ETH. This number is chosen to balance permissionlessness and spam protection for Surge."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Permissionlessness"}),": Testnet participants can accumulate 10,000 testnet ETH with some minor coordination among other participants."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Spam protection"}),": Spam protection: If a block proposer does not provide a proof within the proving liveness window, a malicious block, the proposer will lose the 10,000 testnet ETH proving liveness bond. This creates a loose upperbound on the number of malicious blocks that can be proposed on Surge. Such an upperbound gives any public good entity running the provers a chance to eventually prove these blocks, ensuring the queue of unproven blocks on Surge never becomes too long. In turn, this ensures two critical properties that we must ensure for a rollup:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"withdrawals can be processed in finite time"}),"\n",(0,s.jsx)(n.li,{children:"upgrades can be queued and eventually pushed."}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>a});var o=r(6540);const s={},i=o.createContext(s);function t(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);